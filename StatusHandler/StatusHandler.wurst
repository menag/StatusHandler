/**
 * A package to apply status effects like stun and silence.
 * This package counts the amount of applied and removed status effects,
 * therefore you have to care yourself about how many times you add or
 * remove a status effect from a unit. To use this, you will need a
 * Unit Indexer and have to implement the function in the config file.
 */
package StatusHandler

import StatusHandlerConfig
import DummyCaster

constant DummyCaster STUN_DUMMY_CASTER = new DummyCaster(STUN_ABILITY_ID, "firebolt", DUMMY_PLAYER, false)
constant DummyCaster SILENCE_DUMMY_CASTER = new DummyCaster(SILENCE_ABILITY_ID, "soulburn", DUMMY_PLAYER, false)
constant DummyCaster DISARM_BOTH_DUMMY_CASTER = new DummyCaster(DISARM_BOTH_ABILITY_ID, "drunkenhaze", DUMMY_PLAYER, false)
constant DummyCaster DISARM_MELEE_DUMMY_CASTER = new DummyCaster(DISARM_MELEE_ABILITY_ID, "drunkenhaze", DUMMY_PLAYER, false)
constant DummyCaster DISARM_RANGED_DUMMY_CASTER = new DummyCaster(DISARM_RANGED_ABILITY_ID, "drunkenhaze", DUMMY_PLAYER, false)
constant DummyCaster ENSNARE_DUMMY_CASTER = new DummyCaster(ENSNARE_ABILITY_ID, "ensnare", DUMMY_PLAYER, false)

/**
 * A class which holds all informations about the status effect of the given unit.
 */
public class Status
	protected static Status array status
	protected timer stunTimer
	protected timer silenceTimer
	protected timer disarmBothTimer
	protected timer disarmMeleeTimer
	protected timer disarmRangedTimer
	protected timer ensnareTimer
	protected int stunCounter
	protected int silenceCounter
	protected int disarmBothCounter
	protected int disarmMeleeCounter
	protected int disarmRangedCounter
	protected int ensnareCounter
	
	/**
	 * Constructs a Status object with the given unit.
	 *
	 * unit u - the unit whose Status object is being created
	 */
	construct(unit u)
		int i = u.getIndex()
		status[i] = this
		stunTimer = null
		silenceTimer = null
		disarmBothTimer = null
		disarmMeleeTimer = null
		disarmRangedTimer = null
		ensnareTimer = null
		stunCounter = 0
		silenceCounter = 0
		disarmBothCounter = 0
		disarmMeleeCounter = 0
		disarmRangedCounter = 0
		ensnareCounter = 0
		
	ondestroy
		if stunTimer != null
			stunTimer.release()
		if silenceTimer != null
			silenceTimer.release()
		if disarmBothTimer != null
			disarmBothTimer.release()
		if disarmMeleeTimer != null
			disarmMeleeTimer.release()
		if disarmRangedTimer != null
			disarmRangedTimer.release()
		if ensnareTimer != null
			ensnareTimer.release()

/**
 * Applys a stun to the given unit. The duration is infinite. Hence you have to
 * remove it yourself. The function will count the amount of calls and will therefore
 * last till you removed all stuns which have been applied before.
 */
public function unit.addStun()
	if not this.isStunned()
		STUN_DUMMY_CASTER.castOnTarget(this)
	Status.status[this.getIndex()].stunCounter++

/**
 * Removes one stun stack from the given unit. It is possible that the unit
 * is still stunned afterwards. Throws a warning if a non-existing stun is being
 * removed.
 */
public function unit.removeStun()
	Status.status[this.getIndex()].stunCounter--
	if Status.status[this.getIndex()].stunCounter < 0
		printWarning("StatusHandler: tried removing a non-existing stun.")
		Status.status[this.getIndex()].stunCounter = 0
	if not this.isStunned()
		this.removeAbility(STUN_BUFF_ID)

/**
 * Applies a timed stun to the given unit. If there is already a timed stun on this unit,
 * the stun with the longer duration will be used.
 *
 * real timeout - the stun duration
 */
public function unit.addStunTimed(real timeout)
	int i = this.getIndex()
	if Status.status[i].stunTimer != null and Status.status[i].stunTimer.getRemaining() >= timeout
		return
		
	if Status.status[i].stunTimer == null
		Status.status[i].stunTimer = getTimer()..setData(i)
		this.addStun()
	
	Status.status[i].stunTimer.start(timeout, () -> begin
		int j = GetExpiredTimer().getData()
		j.getUnit().removeStun()
		Status.status[j].stunTimer.release()
		Status.status[j].stunTimer = null
	end)
	
/**
 * Returns a boolean indicating if the unit is stunned.
 *
 * returns true if the unit is stunned, false otherwise
 */
public function unit.isStunned() returns boolean
	return Status.status[this.getIndex()].stunCounter > 0
	
/**
 * Applys a silence to the given unit. The duration is infinite. Hence you have to
 * remove it yourself. The function will count the amount of calls and will therefore
 * last till you removed all silences which have been applied before.
 */
public function unit.addSilence()
	if not this.isSilenced()
		SILENCE_DUMMY_CASTER.castOnTarget(this)
	Status.status[this.getIndex()].silenceCounter++

/**
 * Removes one silence stack from the given unit. It is possible that the unit
 * is still silenced afterwards. Throws a warning if a non-existing silence is being
 * removed.
 */
public function unit.removeSilence()
	Status.status[this.getIndex()].silenceCounter--
	if Status.status[this.getIndex()].silenceCounter < 0
		printWarning("StatusHandler: tried removing a non-existing silence.")
		Status.status[this.getIndex()].silenceCounter = 0
	if not this.isSilenced()
		this.removeAbility(SILENCE_BUFF_ID)
	
/**
 * Applies a timed silence to the given unit. If there is already a timed silence on this unit,
 * the silence with the longer duration will be used.
 *
 * real timeout - the silence duration
 */
public function unit.addSilenceTimed(real timeout)
	int i = this.getIndex()
	if Status.status[i].silenceTimer != null and Status.status[i].silenceTimer.getRemaining() >= timeout
		return
		
	if Status.status[i].silenceTimer == null
		Status.status[i].silenceTimer = getTimer()..setData(i)
		this.addSilence()
	
	Status.status[i].silenceTimer.start(timeout, () -> begin
		int j = GetExpiredTimer().getData()
		j.getUnit().removeSilence()
		Status.status[j].silenceTimer.release()
		Status.status[j].silenceTimer = null
	end)
	
/**
 * Returns a boolean indicating if the unit is silenced.
 *
 * returns true if the unit is silenced, false otherwise
 */
public function unit.isSilenced() returns boolean
	return Status.status[this.getIndex()].silenceCounter > 0
	
/**
 * Ensnares the given unit. The duration is infinite. Hence you have to
 * remove it yourself. The function will count the amount of calls and will therefore
 * last till you removed all ensnares which have been applied before.
 */
public function unit.addEnsnare()
	if not this.isEnsnared()
		ENSNARE_DUMMY_CASTER.castOnTarget(this)
	Status.status[this.getIndex()].ensnareCounter++

/**
 * Removes one ensnare stack from the given unit. It is possible that the unit
 * is still ensnared afterwards. Throws a warning if a non-existing ensnare is being
 * removed.
 */
public function unit.removeEnsnare()
	Status.status[this.getIndex()].ensnareCounter--
	if Status.status[this.getIndex()].ensnareCounter < 0
		printWarning("StatusHandler: tried removing a non-existing ensnare.")
		Status.status[this.getIndex()].ensnareCounter = 0
	if not this.isEnsnared()
		this.removeAbility(ENSNARE1_BUFF_ID)
		this.removeAbility(ENSNARE2_BUFF_ID)

/**
 * Applies a timed ensnare to the given unit. If there is already a timed ensnare on this unit,
 * the ensnare with the longer duration will be used.
 *
 * real timeout - the ensnare duration
 */
public function unit.addEnsnareTimed(real timeout)
	int i = this.getIndex()
	if Status.status[i].ensnareTimer != null and Status.status[i].ensnareTimer.getRemaining() >= timeout
		return
		
	if Status.status[i].ensnareTimer == null
		Status.status[i].ensnareTimer = getTimer()..setData(i)
		this.addEnsnare()
		
	Status.status[i].ensnareTimer.start(timeout, () -> begin
		int j = GetExpiredTimer().getData()
		j.getUnit().removeEnsnare()
		Status.status[j].ensnareTimer.release()
		Status.status[j].ensnareTimer = null
	end)
	
/**
 * Returns a boolean indicating if the unit is ensnared.
 *
 * returns true if the unit is ensnared, false otherwise
 */	
public function unit.isEnsnared() returns boolean
	return Status.status[this.getIndex()].ensnareCounter > 0
	
/**
 * Disarms the given unit. The duration is infinite. Hence you have to
 * remove it yourself. The function will count the amount of calls and will therefore
 * last till you removed all disarmbuffs which have been applied before.
 */
public function unit.addDisarmBoth()
	if not this.isDisarmedBoth()
		DISARM_BOTH_DUMMY_CASTER.castOnTarget(this)
	Status.status[this.getIndex()].disarmBothCounter++

/**
 * Removes one disarm stack from the given unit. It is possible that the unit
 * is still disarmed afterwards. Throws a warning if a non-existing disarmbuff is being
 * removed.
 */
public function unit.removeDisarmBoth()
	Status.status[this.getIndex()].disarmBothCounter--
	if Status.status[this.getIndex()].disarmBothCounter < 0
		printWarning("StatusHandler: tried removing a non-existing disarm both.")
		Status.status[this.getIndex()].disarmBothCounter = 0
	if not this.isDisarmedBoth()
		this.removeAbility(DISARM_BOTH_BUFF_ID)

/**
 * Applies a timed disarm to the given unit. If there is already a timed disarm on this unit,
 * the disarm with the longer duration will be used.
 *
 * real timeout - the disarm duration
 */
public function unit.addDisarmBothTimed(real timeout)
	int i = this.getIndex()
	if Status.status[i].disarmBothTimer != null and Status.status[i].disarmBothTimer.getRemaining() >= timeout
		return
		
	if Status.status[i].disarmBothTimer == null
		Status.status[i].disarmBothTimer = getTimer()..setData(i)
		this.addDisarmBoth()
	
	Status.status[i].disarmBothTimer.start(timeout, () -> begin
		int j = GetExpiredTimer().getData()
		j.getUnit().removeDisarmBoth()
		Status.status[j].disarmBothTimer.release()
		Status.status[j].disarmBothTimer = null
	end)
	
/**
 * Returns a boolean indicating if the unit is disarmed.
 *
 * returns true if the unit is disarmed, false otherwise
 */
public function unit.isDisarmedBoth() returns boolean
	return Status.status[this.getIndex()].disarmBothCounter > 0
	
/**
 * Disarms the given melee unit. The duration is infinite. Hence you have to
 * remove it yourself. The function will count the amount of calls and will therefore
 * last till you removed all melee-disarms which have been applied before.
 */
public function unit.addDisarmMelee()
	if not this.isDisarmedMelee()
		DISARM_MELEE_DUMMY_CASTER.castOnTarget(this)
	Status.status[this.getIndex()].disarmMeleeCounter++

/**
 * Removes one melee-disarm stack from the given unit. It is possible that the unit
 * is still melee-disarmed afterwards. Throws a warning if a non-existing melee-disarm is being
 * removed.
 */
public function unit.removeDisarmMelee()
	Status.status[this.getIndex()].disarmMeleeCounter--
	if Status.status[this.getIndex()].disarmMeleeCounter < 0
		printWarning("StatusHandler: tried removing a non-existing disarm melee.")
		Status.status[this.getIndex()].disarmMeleeCounter = 0
	if not this.isDisarmedMelee()
		this.removeAbility(DISARM_MELEE_BUFF_ID)

/**
 * Applies a timed melee-disarm to the given unit. If there is already a timed melee-disarm on this unit,
 * the melee-disarm with the longer duration will be used.
 *
 * real timeout - the melee-disarm duration
 */
public function unit.addDisarmMeleeTimed(real timeout)
	int i = this.getIndex()
	if Status.status[i].disarmMeleeTimer != null and Status.status[i].disarmMeleeTimer.getRemaining() >= timeout
		return
		
	if Status.status[i].disarmMeleeTimer == null
		Status.status[i].disarmMeleeTimer = getTimer()..setData(i)
		this.addDisarmMelee()
		
	Status.status[i].disarmMeleeTimer.start(timeout, () -> begin
		int j = GetExpiredTimer().getData()
		j.getUnit().removeDisarmMelee()
		Status.status[j].disarmMeleeTimer.release()
		Status.status[j].disarmMeleeTimer = null
	end)
	
/**
 * Returns a boolean indicating if the unit is melee-disarmed.
 *
 * returns true if the unit is melee-disarmed, false otherwise
 */
public function unit.isDisarmedMelee() returns boolean
	return Status.status[this.getIndex()].disarmMeleeCounter > 0
	
/**
 * Disarms the given ranged unit. The duration is infinite. Hence you have to
 * remove it yourself. The function will count the amount of calls and will therefore
 * last till you removed all range-disarms which have been applied before.
 */
public function unit.addDisarmRanged()
	if not this.isDisarmedRanged()
		DISARM_RANGED_DUMMY_CASTER.castOnTarget(this)
	Status.status[this.getIndex()].disarmRangedCounter++

/**
 * Removes one range-disarm stack from the given unit. It is possible that the unit
 * is still range-disarmed afterwards. Throws a warning if a non-existing range-disarm is being
 * removed.
 */
public function unit.removeDisarmRanged()
	Status.status[this.getIndex()].disarmRangedCounter--
	if Status.status[this.getIndex()].disarmRangedCounter < 0
		printWarning("StatusHandler: tried removing a non-existing disarm ranged.")
		Status.status[this.getIndex()].disarmRangedCounter = 0
	if not this.isDisarmedRanged()
		this.removeAbility(DISARM_RANGED_BUFF_ID)

/**
 * Applies a timed range-disarm to the given unit. If there is already a timed range-disarm on this unit,
 * the range-disarm with the longer duration will be used.
 *
 * real timeout - the range-disarm duration
 */
public function unit.addDisarmRangedTimed(real timeout)
	int i = this.getIndex()
	if Status.status[i].disarmRangedTimer != null and Status.status[i].disarmRangedTimer.getRemaining() >= timeout
		return
		
	if Status.status[i].disarmRangedTimer == null
		Status.status[i].disarmRangedTimer = getTimer()..setData(i)
		this.addDisarmRanged()
		
	Status.status[i].disarmRangedTimer.start(timeout, () -> begin
		int j = GetExpiredTimer().getData()
		j.getUnit().removeDisarmRanged()
		Status.status[j].disarmRangedTimer.release()
		Status.status[j].disarmRangedTimer = null
	end)
	
/**
 * Returns a boolean indicating if the unit is range-disarmed.
 *
 * returns true if the unit is range-disarmed, false otherwise
 */
public function unit.isDisarmedRanged() returns boolean
	return Status.status[this.getIndex()].disarmRangedCounter > 0